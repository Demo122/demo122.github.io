[{"categories":["java基础"],"content":"多线程的创建 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"方式一 继承Thread类 创建Thread的子类，并重写run（）方法，run()中的代码为执行体 创建该类的实例，调用它的start（）方法 是调用start方法，不是run方法，如果直接调用run方法只会当作普通方法执行，依然是单线程 public class MyThread { public static void main(String[] args) { /** * 2.创建thread子类的对象，此时线程为新建态 */ Thread t=new ThreadDemo(); // 3.start()启动，进入就绪态，由cpu调度执行 t.start(); for (int i = 0; i \u003c 10; i++) { System.out.println(\"这是主线程：\"+i); } } } /** * 1.定义thread的子类，并重写run方法 */ class ThreadDemo extends Thread{ @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(\"这是子线程：\"+i); } } } ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:1","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"方式二 实现Runnable接口 定义类实现Runnable接口的run方法，run方法为执行体 创建Runnable接口实现类的对象，并将其作为target传入Thread的构造函数获取线程对象 启动start()方法 public class RunnableThreadDemo { public static void main(String[] args) { //2.创建Runnable接口实现类的实例，将其传入到Thread的构造方法中 RunnableThread runnableThread=new RunnableThread(); Thread t=new Thread(runnableThread); t.start(); for (int i = 0; i \u003c 10; i++) { System.out.println(\"这是主线程：\"+i); } } } /** * 1.定义类实现Runnable接口的run方法，run方法为执行体 */ class RunnableThread implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(\"这是子线程：\"+i); } } } ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:2","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"方式三 实现callable接口 创建callable接口的实现类 实现call方法 创建callable接口实现类的实例 使用FutureTask类封装callable对象，并创建futuretask对象 把futuretask对象传入Thread构造函数创建线程对象 启动线程 使用futuretask对象的get()方法获取返回值 public class CallableThreadDemo { public static void main(String[] args) { //3.创建callable接口实现类的实例 Callable\u003cInteger\u003e callable = new CallableThread(10); // 4.使用FutureTask类封装callable对象，并创建futuretask对象 FutureTask\u003cInteger\u003e futureTask = new FutureTask\u003c\u003e(callable); //5.把futuretask对象传入Thread构造函数创建线程对象 Thread t = new Thread(futureTask); //6.启动线程 t.start(); Callable\u003cInteger\u003e callable2 = new CallableThread(20); FutureTask\u003cInteger\u003e futureTask2 = new FutureTask\u003c\u003e(callable2); Thread t2 = new Thread(futureTask2); t2.start(); //7.使用futuretask对象获取返回值 try { //如果此时futurtask的线程没有执行完，这里代码会等待它执行完再取结果 Integer res = futureTask.get(); System.out.println(res); } catch (Exception e) { e.printStackTrace(); } try { Integer res2 = futureTask2.get(); System.out.println(res2); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } // 1.创建callable接口的实现类 class CallableThread implements Callable\u003cInteger\u003e { private int n; public CallableThread(int n) { this.n = n; } // 2、实现call方法 @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i \u003c n; i++) { sum += i; System.out.println(Thread.currentThread().getName()+\"---\"+sum); } return sum; } } ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:3","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"线程常用方法 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"Thread类常用构造方法 Thread() Thread(String name) Thread(Runnable target) Thread(Runnable target, String name) 其中，参数 name为线程名，参数 target为包含线程体的目标对象。 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:1","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"Thread类常用静态方法 currentThread()：返回当前正在执行的线程； interrupted()：返回当前执行的线程是否已经被中断； sleep(long millis)：使当前执行的线程睡眠多少毫秒数； yield()：使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行； ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:2","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"Thread类常用实例方法 getId()：返回该线程的id； getName()：返回该线程的名字； getPriority()：返回该线程的优先级； interrupt()：使该线程中断； isInterrupted()：返回该线程是否被中断； isAlive()：返回该线程是否处于活动状态； isDaemon()：返回该线程是否是守护线程； setDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程； setName(String name)：设置该线程的名字； setPriority(int newPriority)：改变该线程的优先级； join()：等待该线程终止； join(long millis)：等待该线程终止,至多等待多少毫秒数。 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:3","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"线程同步 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"同步代码块 使用synchronized关键字对代码进行上锁 示例： public void drawMoney(double draw_money){ //获取当前线程名字 String name=Thread.currentThread().getName(); //this作为锁对象 synchronized (this){ if (this.money\u003e=draw_money){ System.out.println(name+\"进来了，取走了\"+draw_money); this.money-=draw_money; System.out.println(\"余额：\"+this.money); }else { System.out.println(name+\"进来了,钱不够了\"); } } } 锁对象用任意唯一对象好不好？不好，会影响无关线程的执行 锁对象的规范要求 建议使用共享资源作为锁对象 对于实例方法建议使用this作为锁对象 对于静态方法建议使用字节码（类名.class）对象作为锁对象 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:1","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"同步方法 对方法加上synchronized关键字上锁 示例： public synchronized void drawMoney(double draw_money) { //获取当前线程名字 String name = Thread.currentThread().getName(); if (this.money \u003e= draw_money) { System.out.println(name + \"进来了，取走了\" + draw_money); this.money -= draw_money; System.out.println(\"余额：\" + this.money); } else { System.out.println(name + \"进来了,钱不够了\"); } } 底层原理： 底层也是有隐式锁对象，锁住整个方法 如果是实例方法，默认使用this作为锁对象 如果是静态方法，默认使用类名.class作为锁对象 ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:2","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java基础"],"content":"ReetrantLock 为了更清晰的表达加锁和解锁，就jdk5以后提供了一个新的锁对象，lock,更加灵活方便 Lock是接口，我们使用它的实现类ReetrantLock，它提供了很多锁操作 void lock 获得锁 void unlock 解锁 示例： //加上final修饰，变成唯一不可替换的锁 private final Lock lock = new ReentrantLock(); public void drawMoney(double draw_money) { //获取当前线程名字 String name = Thread.currentThread().getName(); //上锁 lock.lock(); try { if (this.money \u003e= draw_money) { System.out.println(name + \"进来了，取走了\" + draw_money); this.money -= draw_money; System.out.println(\"余额：\" + this.money); } else { System.out.println(name + \"进来了,钱不够了\"); } } finally { //解锁 lock.unlock(); } } ","date":"2022-06-17","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:3","tags":["多线程"],"title":"Java基础之多线程","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["java框架"],"content":"Springboot笔记 ","date":"2022-06-17","objectID":"/springboot2/:0:0","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"基础 ","date":"2022-06-17","objectID":"/springboot2/:1:0","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"集成junit 导入springboot-test包 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 编写测试类和测试方法，在测试类上加注解@SpringBootTest @SpringBootTest(classes = Springboot02JunitApplication.class) class Springboot02JunitApplicationTests { @Autowired private BookService bookService; @Test public void testBookService(){ bookService.run(); } @Test void contextLoads() { System.out.println(\"test...\"); } } 如果测试类和springboot启动类不在一个层级，通过设置class属性来指定启动类 ","date":"2022-06-17","objectID":"/springboot2/:1:1","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"运维实用 ","date":"2022-06-17","objectID":"/springboot2/:2:0","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"开发实用 ","date":"2022-06-17","objectID":"/springboot2/:3:0","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"原理 ","date":"2022-06-17","objectID":"/springboot2/:4:0","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"POM ","date":"2022-06-17","objectID":"/springboot2/:5:0","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java框架"],"content":"spring-boot-starter-web \u003c!-- springboot-web --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2022-06-17","objectID":"/springboot2/:5:1","tags":["Springboot"],"title":"Springboot笔记","uri":"/springboot2/"},{"categories":["java基础"],"content":"字符编解码 字符集 GBK UTF-8 GBK: 汉字占两个字节 UTF-8: 汉字占三个字节 任何字符集中英文和数字都占一个字节 /** * 字符集 GBK UTF-8 * GBK: 汉字占两个字节 * UTF-8: 汉字占三个字节 * 任何字符集中英文和数字都占一个字节 */ public class CharsetTest { public static void main(String[] args) throws UnsupportedEncodingException { //1.编码 String name = \"123明里的博客\"; byte[] bytes = name.getBytes(\"GBK\"); System.out.println(bytes.length); System.out.println(Arrays.toString(bytes)); String nstr=new String(bytes,\"GBK\"); System.out.println(nstr); } } ","date":"2022-06-16","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/:1:0","tags":["IO流"],"title":"Java基础之IO流","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/"},{"categories":["java基础"],"content":"IO流 ","date":"2022-06-16","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/:2:0","tags":["IO流"],"title":"Java基础之IO流","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/"},{"categories":["java基础"],"content":"字节流：InputStream、OutputStream 字节输入流：一般用FileInputStream public class IOStream { public static void main(String[] args) throws Exception { //1.传入文件路径，创建一个文件字节输入流 InputStream fileInputStream = new FileInputStream(\"java_study/src/main/resources/IOStream.txt\"); //2.读取一个字节,每次读一个字节 int read = fileInputStream.read(); System.out.println((char)read); //使用字节数组读 // byte[] buffer = new byte[9]; // fileInputStream.read(buffer); // System.out.println(new String(buffer)); //读取全部字节,jdk9 // byte[] all=fileInputStream.readAllBytes(); // System.out.println(new String(all)); } } 字节输出流：一般用FileOutputStream //1.传入文件路径，创建一个文件字节输出流 OutputStream os = new FileOutputStream(\"java_study/src/main/resources/IOStreamOutput.txt\"); try { //2.写数据 os.write(98); os.write(\"你好\".getBytes()); os.flush(); //刷新 } catch (Exception e) { e.printStackTrace(); } finally { os.close(); } 无法避免读取中文乱码的问题,适合用于文件数据的拷贝 ","date":"2022-06-16","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/:2:1","tags":["IO流"],"title":"Java基础之IO流","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/"},{"categories":["java基础"],"content":"字节流实例–复制文件 public class CopyFile { public static void main(String[] args) { InputStream ins = null; OutputStream os = null; try { //1.创建字节输入流 ins = new FileInputStream(\"java_study/src/main/resources/12.jpeg\"); //2.创建字节输出流 os = new FileOutputStream(\"java_study/src/main/resources/1222.jpeg\"); //3.定义字节数组 byte[] buffer = new byte[1024]; int len = 0; //使用len来记录读取了多少字节，方便读多少写多少 //4.循环遍历读取 while ((len = ins.read(buffer)) != -1) { os.write(buffer, 0, len); //使用len来记录读取了多少字节，方便读多少写多少，不会多写重复的 } } catch (Exception e) { e.printStackTrace(); } finally { //释放资源 try { if(ins!=null) ins.close(); if(os!=null) os.close(); } catch (IOException e) { e.printStackTrace(); } } } } ","date":"2022-06-16","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/:2:2","tags":["IO流"],"title":"Java基础之IO流","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/"},{"categories":["java基础"],"content":"字符流：Reader、Writer 读取中文的文本，推荐使用字符流 字符输入流：FileReader public static void main(String[] args) throws Exception { //字符流 Reader reader=new FileReader(\"java_study/src/main/resources/IOStream.txt\"); //读一个 // int read = reader.read(); // System.out.println((char)read); //使用字符数组，读一堆 char[] buffer =new char[10]; int len=0; while((len=reader.read(buffer))!=-1){ String content=new String(buffer,0,len); System.out.print(content); } } 字符输出流：FileWriter public static void main(String[] args) throws Exception { Writer writer=new FileWriter(\"java_study/src/main/resources/IOStream22.txt\"); //append设置为true,则为追加数据 //Writer writer=new FileWriter(\"java_study/src/main/resources/IOStream22.txt\"，true); //直接写字符串 writer.write(\"这是字符流写数据\"); writer.write(98); writer.write(\"\\n\"); char [] chars={'你','d','2'}; writer.write(chars,0,2); //刷新内存，将内容写入到硬盘中 //刷新后可以继续写 writer.flush(); //close会触发刷新，但是close后无法再继续写 writer.close(); } ","date":"2022-06-16","objectID":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/:2:3","tags":["IO流"],"title":"Java基础之IO流","uri":"/java%E5%9F%BA%E7%A1%80%E4%B9%8Bio%E6%B5%81/"},{"categories":["工具"],"content":"1. git入门 学习了git使用，搭建了docsify个人博客，主要用于记录学习过程，Java笔记 其中git使用常用命令为： git init 初始化仓库 git add xxx.xx 添加文件 git add -A 添加所有修改的文件 git commit -m \"xxxx\" git reset --hard HEAD^ 返回上一版本，HEAD时当前版本 git branch xxx 创建分支 git checkout xx 切换分支 git merge xx 合并分支 git push origin xx 更新到github git status 查看当前状态 .... 附上参考资料，不会再查 git指令 ","date":"2022-06-10","objectID":"/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/:1:0","tags":["git"],"title":"Git常用操作","uri":"/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"2. git开发实践 ","date":"2022-06-10","objectID":"/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/:2:0","tags":["git"],"title":"Git常用操作","uri":"/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"2.1 版本回退 2.1.1 回退至上一个版本 git reset --hard HEAD 2.1.2 对push的版本进行回退 ","date":"2022-06-10","objectID":"/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/:2:1","tags":["git"],"title":"Git常用操作","uri":"/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["linux"],"content":"crontab定时任务 Linux crontab 是用来定期执行程序的命令。 当安装完成操作系统之后，默认便会启动此任务调度命令。 crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。 ","date":"2022-06-09","objectID":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:1:0","tags":["crontab定时任务"],"title":"crontab定时任务","uri":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["linux"],"content":"安装使用crontab 安装 sudo apt-te install cron 使用 service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 service crond status //查看服务状态 常用命令 查看crontab定时执行任务列表 crontab -l 编辑crontab定时执行任务 crontab -e 删除crontab定时任务 crontab -r ","date":"2022-06-09","objectID":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:1:1","tags":["crontab定时任务"],"title":"crontab定时任务","uri":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["linux"],"content":"编写crontab -e nano使用 ctrl+o 后，filename…..，直接回车保存文件 ctrl+x 退出 官方例子 # For example, you can run a backup of all your user accounts # at 5 a.m every week with: # 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ # # For more information see the manual pages of crontab(5) and cron(8) # # m h dom mon dow command 时间格式如下： f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。 当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推 * * * * * - - - - - | | | | | | | | | +----- 星期中星期几 (0 - 6) (星期天 为0) | | | +---------- 月份 (1 - 12) | | +--------------- 一个月中的第几天 (1 - 31) | +-------------------- 小时 (0 - 23) +------------------------- 分钟 (0 - 59) 实例 每一分钟执行一次 /bin/ls： * * * * * /bin/ls ","date":"2022-06-09","objectID":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:1:2","tags":["crontab定时任务"],"title":"crontab定时任务","uri":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["linux"],"content":"运行python程序 运行python程序需要注意要使用绝对路径，包括解释器和py文件的绝对路径 可以通过whereis python来查看python解释器的位置 例子 */58 * * * * /usr/bin/python3 /home/xx/pycode/jcad.py \u003e\u003e /home/xx/pycode/jcad.log ","date":"2022-06-09","objectID":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/:1:3","tags":["crontab定时任务"],"title":"crontab定时任务","uri":"/crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"categories":["数据库"],"content":"mysql ","date":"2022-06-09","objectID":"/mysql/:0:0","tags":["Mysql"],"title":"mysql笔记","uri":"/mysql/"},{"categories":["数据库"],"content":"mysql安装和配置 MySQL 5.7.24 解压版,解压安装 配置 添加环境变量 新建配置文件 新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 初始化MySQL mysqld --initialize-insecure 需要管理员权限 注册MySQL服务 mysqld -install 启动MySQL服务 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 修改默认账户密码 在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 登录MySQL mysql -uroot -p1234 登陆参数： mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 退出 退出mysql： exit quit 卸载MySQL 敲入net stop mysql，回车。 net stop mysql 再敲入mysqld -remove mysql，回车。 mysqld -remove mysql 最后删除MySQL目录及相关的环境变量。 至此，MySQL卸载完成！ MySql数据模型 关系型数据库： 关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库 关系型数据库的优点： 都是使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 关系型数据库都可以通过SQL进行操作，所以使用方便。 复杂查询。现在需要查询001号订单数据，我们可以看到该订单是1号客户的订单，而1号订单是李聪这个客户。以后也可以在一张表中进行统计分析等操作。 数据存储在磁盘中，安全。 ","date":"2022-06-09","objectID":"/mysql/:1:0","tags":["Mysql"],"title":"mysql笔记","uri":"/mysql/"},{"categories":["数据库"],"content":"SQL基础 ","date":"2022-06-09","objectID":"/mysql/:2:0","tags":["Mysql"],"title":"mysql笔记","uri":"/mysql/"},{"categories":["数据库"],"content":"SQL概述 英文：Structured Query Language，简称 SQL SQL 语句可以单行或多行书写，以分号结尾。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 注释 单行注释: – 注释内容 或 #注释内容(MySQL 特有) 注意：使用– 添加单行注释时，–后面一定要加空格，而#没有要求。 多行注释: /* 注释 */ ","date":"2022-06-09","objectID":"/mysql/:2:1","tags":["Mysql"],"title":"mysql笔记","uri":"/mysql/"},{"categories":["数据库"],"content":"SQL分类 DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等 DDL简单理解就是用来操作数据库，表等 DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改 DML简单理解就对表中数据进行增删改 DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据) DQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。 DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户 DML简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。 注意： 以后我们最常操作的是 DML 和 DQL ，因为我们开发中最常操作的就是数据。 DDL:操作数据库 查询 SHOW DATABASES; /* 查询所有的数据库 */ 创建数据库 创建数据库 CREATE DATABASE 数据库名称; 创建数据库(判断，如果不存在则创建) CREATE DATABASE IF NOT EXISTS 数据库名称; 删除数据库 删除数据库 DROP DATABASE 数据库名称; 删除数据库(判断，如果存在则删除) DROP DATABASE IF EXISTS 数据库名称; 使用数据库 使用数据库 USE 数据库名称; 查看当前使用的数据库 SELECT DATABASE(); DML:操作表 操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。 查询表 查询当前数据库下所有表名称 SHOW TABLES; 查询表结构 DESC 表名称; 创建表 创建表 CREATE TABLE 表名 ( 字段名1 数据类型1, 字段名2 数据类型2, … 字段名n 数据类型n ); /*例如*/ create table tb_user ( id int, username varchar(20), password varchar(32) ); 数据类型 数值 tinyint : 小整数型，占一个字节 int ： 大整数类型，占四个字节 eg ： age int double ： 浮点类型 使用格式： 字段名 double(总长度,小数点后保留的位数) eg ： score double(5,2) 日期 date ： 日期值。只包含年月日 eg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒 字符串 char ： 定长字符串。 优点：存储性能高 缺点：浪费空间 eg ： name char(10) 如果存储的数据字符个数不足10个，也会占10个的空间 varchar ： 变长字符串。 优点：节约空间 缺点：存储性能底 eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间 删除表 删除表 DROP TABLE 表名; 删除表时判断表是否存在 DROP TABLE IF EXISTS 表名; 修改表 修改表名 ALTER TABLE 表名 RENAME TO 新的表名; -- 将表名student修改为stu alter table student rename to stu; 添加一列 ALTER TABLE 表名 ADD 列名 数据类型; -- 给stu表添加一列address，该字段类型是varchar(50) alter table stu add address varchar(50); 修改数据类型 ALTER TABLE 表名 MODIFY 列名 新数据类型; -- 将stu表中的address字段的类型改为 char(50) alter table stu modify address char(50); 修改列名和数据类型 ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; -- 将stu表中的address字段名改为 addr，类型改为varchar(50) alter table stu change address addr varchar(50); 删除列 ALTER TABLE 表名 DROP 列名; -- 将stu表中的addr字段 删除 alter table stu drop addr; 怎删改查 对数据进行增（insert）删（delete）改（update）操作 添加数据 给指定列添加数据 INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…); 给全部列添加数据 INSERT INTO 表名 VALUES(值1,值2,…); 批量添加数据 INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; ","date":"2022-06-09","objectID":"/mysql/:2:2","tags":["Mysql"],"title":"mysql笔记","uri":"/mysql/"},{"categories":["java框架"],"content":"Spring配置-applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!--组件扫描 扫描service和mapper--\u003e \u003ccontext:component-scan base-package=\"com.pd\"\u003e \u003c!--排除controller的扫描--\u003e \u003ccontext:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/\u003e \u003c/context:component-scan\u003e \u003c!--加载propeties文件--\u003e \u003ccontext:property-placeholder location=\"classpath:jdbc.properties\"\u003e\u003c/context:property-placeholder\u003e \u003c!--配置数据源信息--\u003e \u003cbean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"${jdbc.driver}\"\u003e\u003c/property\u003e \u003cproperty name=\"jdbcUrl\" value=\"${jdbc.url}\"\u003e\u003c/property\u003e \u003cproperty name=\"user\" value=\"${jdbc.username}\"\u003e\u003c/property\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!--配置sessionFactory, spring集成mybatis--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"\u003e\u003c/property\u003e \u003c!--加载mybatis核心文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-spring.xml\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!--扫描mapper所在的包 为mapper创建实现类--\u003e \u003cbean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"\u003e \u003cproperty name=\"basePackage\" value=\"com.pd.mapper\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!--声明式事务控制--\u003e \u003c!--平台事务管理器--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!--配置事务增强--\u003e \u003ctx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\" \u003e \u003ctx:attributes\u003e \u003ctx:method name=\"*\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!--事务的aop织入--\u003e \u003caop:config\u003e \u003c!-- \u003caop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.pd.service.impl.*.*(..))\"\u003e\u003c/aop:advisor\u003e--\u003e \u003caop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.pd.controller.*.*(..))\"\u003e\u003c/aop:advisor\u003e \u003c/aop:config\u003e \u003c!--事务的注解驱动--\u003e \u003c!-- \u003ctx:annotation-driven/\u003e--\u003e \u003c/beans\u003e ","date":"2022-06-09","objectID":"/ssm%E9%85%8D%E7%BD%AE/:1:0","tags":["ssm配置"],"title":"ssm配置","uri":"/ssm%E9%85%8D%E7%BD%AE/"},{"categories":["java框架"],"content":"SpringMVC.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!--Controller的组件扫描--\u003e \u003ccontext:component-scan base-package=\"com.pd.controller\"\u003e \u003ccontext:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/\u003e \u003c/context:component-scan\u003e \u003c!--mvc的注解驱动--\u003e \u003cmvc:annotation-driven /\u003e \u003c!--开放资源的访问--\u003e \u003c!--\u003cmvc:resources mapping=\"/js/**\" location=\"/js/\"/\u003e \u003cmvc:resources mapping=\"/img/**\" location=\"/img/\"/\u003e--\u003e \u003cmvc:default-servlet-handler/\u003e \u003c!--配置内部资源视图解析器--\u003e \u003cbean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e \u003c!-- /jsp/success.jsp --\u003e \u003cproperty name=\"prefix\" value=\"/WEB-INF/pages/\"\u003e\u003c/property\u003e \u003cproperty name=\"suffix\" value=\".jsp\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c!--配置处理器映射器--\u003e \u003c!--\u003cbean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"\u003e \u003cproperty name=\"messageConverters\"\u003e \u003clist\u003e \u003cbean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/\u003e \u003c/list\u003e \u003c/property\u003e \u003c/bean\u003e--\u003e \u003c!-- \u0026lt;!\u0026ndash;配置文件上传解析器\u0026ndash;\u0026gt;--\u003e \u003c!-- \u003cbean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"\u003e--\u003e \u003c!-- \u003cproperty name=\"defaultEncoding\" value=\"UYF-8\"/\u003e--\u003e \u003c!-- \u003cproperty name=\"maxUploadSize\" value=\"500000\"/\u003e--\u003e \u003c!-- \u003c/bean\u003e--\u003e \u003c/beans\u003e ","date":"2022-06-09","objectID":"/ssm%E9%85%8D%E7%BD%AE/:2:0","tags":["ssm配置"],"title":"ssm配置","uri":"/ssm%E9%85%8D%E7%BD%AE/"},{"categories":["java框架"],"content":"Mybatis-Spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!--定义别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.pd.pojo\"\u003e\u003c/package\u003e \u003c/typeAliases\u003e \u003c/configuration\u003e ","date":"2022-06-09","objectID":"/ssm%E9%85%8D%E7%BD%AE/:3:0","tags":["ssm配置"],"title":"ssm配置","uri":"/ssm%E9%85%8D%E7%BD%AE/"},{"categories":["java框架"],"content":"web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\u003e \u003c!--配置全局过滤的filter--\u003e \u003cfilter\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eUTF-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c!--配置SpringMVC的前端控制器--\u003e \u003cservlet\u003e \u003cservlet-name\u003eDispatcherServlet\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:spring-mvc.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eDispatcherServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c!--全局初始化参数--\u003e \u003ccontext-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:applicationContext.xml\u003c/param-value\u003e \u003c/context-param\u003e \u003c!--配置监听器--\u003e \u003clistener\u003e \u003clistener-class\u003eorg.springframework.web.context.ContextLoaderListener\u003c/listener-class\u003e \u003c/listener\u003e \u003c/web-app\u003e ","date":"2022-06-09","objectID":"/ssm%E9%85%8D%E7%BD%AE/:4:0","tags":["ssm配置"],"title":"ssm配置","uri":"/ssm%E9%85%8D%E7%BD%AE/"},{"categories":["java框架"],"content":"jdbc.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssm jdbc.username=root jdbc.password=1234 ","date":"2022-06-09","objectID":"/ssm%E9%85%8D%E7%BD%AE/:5:0","tags":["ssm配置"],"title":"ssm配置","uri":"/ssm%E9%85%8D%E7%BD%AE/"},{"categories":["java框架"],"content":"log4j.properties # # Hibernate, Relational Persistence for Idiomatic Java # # License: GNU Lesser General Public License (LGPL), version 2.1 or later. # See the lgpl.txt file in the root directory or \u003chttp://www.gnu.org/licenses/lgpl-2.1.html\u003e. # ### direct log messages to stdout ### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.err log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n ### direct messages to file hibernate.log ### #log4j.appender.file=org.apache.log4j.FileAppender #log4j.appender.file.File=hibernate.log #log4j.appender.file.layout=org.apache.log4j.PatternLayout #log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n ### set log levels - for more verbose logging change 'info' to 'debug' ### log4j.rootLogger=all, stdout ","date":"2022-06-09","objectID":"/ssm%E9%85%8D%E7%BD%AE/:6:0","tags":["ssm配置"],"title":"ssm配置","uri":"/ssm%E9%85%8D%E7%BD%AE/"},{"categories":["面试"],"content":"八股文 牛客八股 javaguide ","date":"2022-06-09","objectID":"/%E9%9D%A2%E8%AF%95/:1:0","tags":["面试资料","算法","刷题"],"title":"八股文","uri":"/%E9%9D%A2%E8%AF%95/"},{"categories":["java项目","实战"],"content":"仿牛客社区 ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:0:0","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"springboot集成第三方 ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:1:0","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"集成reids 导包 spring-boot-starter-data-redis \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 配置Redis 配置数据源 spring: redis: database: 11 host: localhost port: 6379 编写配置类，构造RedisTemplate @Configuration public class RedisConfig { @Bean public RedisTemplate\u003cString, Object\u003e redisTemplate(RedisConnectionFactory factory) { RedisTemplate\u003cString, Object\u003e template = new RedisTemplate\u003c\u003e(); template.setConnectionFactory(factory); // 设置key的序列化方式 template.setKeySerializer(RedisSerializer.string()); // 设置value的序列化方式 template.setValueSerializer(RedisSerializer.json()); // 设置hash的key的序列化方式 template.setHashKeySerializer(RedisSerializer.string()); // 设置hash的value的序列化方式 template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } 访问Redis ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:1:1","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"集成kafka kafka启动 启动zookeeper bin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties 启动kafka bin\\windows\\kafka-server-start.bat config\\server.properties 创建主题 kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test springboot整合kafka 引入依赖，spring-kafka \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.kafka\u003c/groupId\u003e \u003cartifactId\u003espring-kafka\u003c/artifactId\u003e \u003c/dependency\u003e 配置kafka，配置server、consumer spring: kafka: bootstrap-servers: localhost:9092 consumer: group-id: test-consumer-group enable-auto-commit: true auto-commit-interval: 3000 访问kafka 生产者使用 kafkaTemplate.send(topic,content);发送消息 消费者使用@KafkaListener(topics = {“test”})注解监听某些主题，消息封装成ConsumerRecord类型handleMessage(ConsumerRecord consumerRecord) @SpringBootTest(classes = NowcoderCommunityApplication.class) public class KafkaTest { @Autowired private KafkaProducer kafkaProducer; @Test public void testKafka(){ kafkaProducer.sendMessage(\"test\",\"这是第一条kafkaProducer\"); kafkaProducer.sendMessage(\"test\",\"hah\"); kafkaProducer.sendMessage(\"test\",\"你好\"); try { Thread.sleep(1000*5); } catch (InterruptedException e) { e.printStackTrace(); } } } //生产者 @Component class KafkaProducer{ @Autowired private KafkaTemplate kafkaTemplate; public void sendMessage(String topic,String content){ kafkaTemplate.send(topic,content); } } //消费者 @Component class KafkaConsumer{ @Autowired private KafkaTemplate kafkaTemplate; //监听某些主题 @KafkaListener(topics = {\"test\"}) public void handleMessage(ConsumerRecord consumerRecord){ System.out.println(consumerRecord.value()); } } ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:1:2","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"功能实现 ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:2:0","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"动实现分页 分页sql语句 select * from discuss_post order by type desc, create_time desc limit #{offset}, #{limit} 定义分页信息对象，page类 /** * 封装分页相关的信息. */ public class Page { // 当前页码 private int current = 1; // 显示上限 private int limit = 10; // 数据总数(用于计算总页数) private int rows; // 查询路径(用于复用分页链接) private String path; public int getCurrent() { return current; } public void setCurrent(int current) { if (current \u003e= 1) { this.current = current; } } public int getLimit() { return limit; } public void setLimit(int limit) { if (limit \u003e= 1 \u0026\u0026 limit \u003c= 100) { this.limit = limit; } } public int getRows() { return rows; } public void setRows(int rows) { if (rows \u003e= 0) { this.rows = rows; } } public String getPath() { return path; } public void setPath(String path) { this.path = path; } /** * 获取当前页的起始行 * * @return */ public int getOffset() { // current * limit - limit return (current - 1) * limit; } /** * 获取总页数 * * @return */ public int getTotal() { // rows / limit [+1] if (rows % limit == 0) { return rows / limit; } else { return rows / limit + 1; } } /** * 获取起始页码 * * @return */ public int getFrom() { int from = current - 2; return from \u003c 1 ? 1 : from; } /** * 获取结束页码 * * @return */ public int getTo() { int to = current + 2; int total = getTotal(); return to \u003e total ? total : to; } } controller中接收分页信息并调用语句分页查找 ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:2:1","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"发送邮件 邮箱设置 启用客户端smtp服务，可以室友163邮箱、qq邮箱等等 Spring boot 集成javamail 导入jar包 \u003c!-- java mail--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-mail\u003c/artifactId\u003e \u003c/dependency\u003e 配置邮箱参数 spring: mail: host: smtp.163.com port: 465 username: xxxx@163.com password: xxxxx protocol: smtps # 指定协议 properties: mail.smtp.ssl.enable: true 代码实现 @Component public class MailClient { private static final Logger logger = LoggerFactory.getLogger(MailClient.class); @Autowired private JavaMailSender mailSender; @Value(\"${spring.mail.username}\") private String from; public void sendMail(String to, String subject, String context) { try { MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage); mimeMessageHelper.setFrom(from); mimeMessageHelper.setTo(to); mimeMessageHelper.setSubject(subject); mimeMessageHelper.setText(context, true); mailSender.send(mimeMessage); } catch (MessagingException e) { logger.error(\"发送邮件失败：\" + e.getMessage()); } } } 测试，使用thymeleaf模板发送html的邮件 @Test public void testSendHTMLMail(){ Context context=new Context(); context.setVariable(\"username\",\"userxx\"); String content = templateEngine.process(\"/mail/mailexample\", context); mailClient.sendMail(\"user@qq.com\",\"suject\",content); } ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:2:2","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"经验 ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:3:0","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["java项目","实战"],"content":"ajxa请求经过springmvc拦截器后response重定向问题 问题：ajxa请求经过springmvc拦截器后response重定向后，浏览器会再次请求重定向的页面，但是不会刷新显示 解决：可以设置ajax请求拦截后将重定向页面url作为json数据返回，在ajax回调处理函数中进行页面跳转 代码 java代码 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { pass { //如果request.getHeader(\"X-Requested-With\") 返回的是\"XMLHttpRequest\"说明就是ajax请求，需要特殊处理 否则直接重定向就可以了 if(\"XMLHttpRequest\".equals(request.getHeader(\"X-Requested-With\"))){ //自定义json数据返回，包含重定向的地址 JSONObject res=new JSONObject(); res.put(\"redirect\",request.getContextPath() + \"/login\"); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(res.toJSONString()); }else{ // 如果不是ajax 就正常重定向 response.sendRedirect(request.getContextPath() + \"/login\"); } return false; return true; } js代码 $.post( reuqest_url, function (data) { data1 = JSON.parse(JSON.stringify(data)); // console.log(data); if (data1.redirect != null) { window.location.href = CONTEXT_PATH + data1.redirect; } } ); ​ ","date":"2022-06-09","objectID":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/:3:1","tags":["java项目","实战"],"title":"仿牛客社区","uri":"/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%A4%BE%E5%8C%BA/"},{"categories":["面试","算法"],"content":"牛客算法top101 ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:0:0","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"链表 ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:0","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"BM1 反转链表 题目 给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 链接 解答 步骤 step 1：优先处理空链表，空链表不需要反转。 step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。 step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点。 step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。 代码 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode ReverseList(ListNode head) { //如果是空链表就直接返回 if(head==null){ return head; } ListNode pre=null; ListNode cur=head; while(cur!=null){ ListNode temp = cur.next; //断开链表，要记录后续一个 cur.next = pre; //当前的next指向前一个 pre = cur; //前一个更新为当前 cur = temp; //当前更新为刚刚记录的后一个 } return pre; } } ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:1","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"BM2 反转链表内指定区间 题目 将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)O(n)，空间复杂度 O(1)O(1)。 链接 解答 步骤 肯定是要先找到了第m个位置才能开始反转链表，而反转的部分就是从第m个位置到第n个位置。 step 1：我们可以在链表前加一个表头，后续返回时去掉就好了，因为如果要从链表头的位置反转，也很方便。 step 2：使用两个指针，一个指向当前节点，一个指向前序节点。 step 3：依次遍历链表，到第m个的位置。 step 4：对于从m到n这些个位置的节点，依次断掉指向后续的指针，反转指针方向。 step 5：返回时去掉我们添加的表头。 代码 public class Solution { /** * * @param head ListNode类 * @param m int整型 * @param n int整型 * @return ListNode类 */ public ListNode reverseBetween (ListNode head, int m, int n) { // write code here ListNode pre=null; ListNode cur=head; for(int i=1; i\u003cm;i++){ pre=cur; cur=cur.next; } for(int i=m;i\u003cn;i++){ //头插法 ListNode temp=cur.next; cur.next=temp.next; temp.next=pre.next; pre.next=temp; } return head; } } ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:2","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"BM3 合并两个排序的链表 题目 输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。 要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n) 示例 如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6} 链接 解答 步骤 如果一个链表为空，直接返回另一个链表 两个链表的表头元素进行比较，将最小的加入到新链表 把剩下的链表的结点加入到新链表 代码 public class Solution { public ListNode Merge(ListNode list1,ListNode list2) { //如果一个链表为空，直接返回另一个链表 if(list1==null){ return list2; } if(list2==null){ return list1; } //两个链表的表头元素进行比较，将最小的加入到新链表 ListNode head=new ListNode(0); ListNode cur=head; while(list1!=null\u0026\u0026list2!=null){ //比较两链表的首元素 if(list1.val\u003clist2.val){ //把小的加入到新链表 cur.next=list1; //list1往下 list1=list1.next; }else{ cur.next=list2; list2=list2.next; } //新链表往下 cur=cur.next; } //把剩下的链表的结点加入到新链表 if(list2!=null){ cur.next=list2; } if(list1!=null){ cur.next=list1; } return head.next; } } ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:3","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"BM4 判断链表是否有环 题目 描述：给定一个链表，判断是否有环 链接 解答 思路：使用快慢双指针遍历，如果快慢指针为null，说明无环，否则快指针迟早会追上慢指针，两者相遇，说明有环 代码 /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if(head==null) return false; ListNode fast=head; ListNode slow=head; while(fast.next!=null\u0026\u0026fast.next.next!=null){ fast=fast.next.next; slow=slow.next; //相遇，说明有环 if(fast==slow){ return true; } } //退出while,说明fast到链表尾遇到了null，无环 return false; } } ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:4","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"BM5 找出链表中环的入口 题目 描述：给定一个链表，如果有环，找出它的入口 链接 解答 思路 步骤 使用判断链表中是否有环中的方法判断链表是否有环，并找到相遇的节点 慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。 再次相遇的地方就是环的入口 代码 import java.util.*; /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ public class Solution { public ListNode hasCycle(ListNode head) { if(head == null) //先判断链表为空的情况 return null; ListNode fast = head; //快慢双指针 ListNode slow = head; while(fast != null \u0026\u0026 fast.next != null){ //如果没环快指针会先到链表尾 fast = fast.next.next; //快指针移动两步 slow = slow.next; //慢指针移动一步 if(fast == slow) //相遇则有环，返回相遇的位置 return slow; } return null; //到末尾说明没有环，返回null } public ListNode EntryNodeOfLoop(ListNode pHead) { ListNode slow = hasCycle(pHead); if(slow == null) //没有环 return null; ListNode fast = pHead; //快指针回到表头 while(fast != slow){ //再次相遇即是环入口 fast = fast.next; slow = slow.next; } return slow; } } ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:5","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"BM6 链表中的倒数第k个节点 题目 一个长度为n的链表，返回原链表中从倒数第k个结点至尾节点的全部节点 如果该链表长度小于k，请返回一个长度为 0 的链表 链接 解答 思路：让两个指针一前一后，相隔刚好为k，这样，当快指针遍历到链表尾时，满指针刚好在倒数的第k个位置 代码 import java.util.*; /* * public class ListNode { * int val; * ListNode next = null; * public ListNode(int val) { * this.val = val; * } * } */ public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param pHead ListNode类 * @param k int整型 * @return ListNode类 */ public ListNode FindKthToTail (ListNode pHead, int k) { // write code here ListNode fast=pHead; ListNode slow=pHead; //先让快指针走到顺数第k个位置 for(int i=0;i\u003ck;i++){ if(fast!=null){ fast=fast.next; }else{ //没有到第k个位置就为空了，说嘛链表长度小于k，返回null return null; } } //slow、fast一起往下走，当fast走到底时，slow指向倒数第k个 while(fast!=null){ fast=fast.next; slow=slow.next; } return slow; } } ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:6","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["面试","算法"],"content":"标题 题目 描述 示例 链接 解答 思路 步骤 代码 ","date":"2022-06-09","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/:1:7","tags":["面试","算法","刷题","牛客算法top101"],"title":"牛客算法top101","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95top101/"},{"categories":["随笔"],"content":"随笔 ","date":"2022-06-09","objectID":"/%E9%9A%8F%E7%AC%94/:0:0","tags":["感想"],"title":"随笔","uri":"/%E9%9A%8F%E7%AC%94/"},{"categories":["随笔"],"content":"2022/6/9 投鼎桥科技。。。 ","date":"2022-06-09","objectID":"/%E9%9A%8F%E7%AC%94/:1:0","tags":["感想"],"title":"随笔","uri":"/%E9%9A%8F%E7%AC%94/"},{"categories":["docker","开发工具"],"content":"1. docker安装 ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:1:0","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"ubuntu中安装docker 1. 卸载旧版本 sudo apt-get remove docker docker-engine docker.io containerd runc 2. 安装依赖 sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 3. 添加docker官方gpg密钥，这里改成中科大镜像的 curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 4. 设置稳定版本库，也换成中科大的 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 5. 安装docker,默认是安装最新版 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin ​ 你可以使用如下命令查看当前存储库中可用的版本，自己指定版本号 ​ 查看命令为： apt-cache madison docker-ce 安装，\u003cVERSION_STRING\u003e替换成你的版本号 sudo apt-get install docker-ce=\u003cVERSION_STRING\u003e docker-ce-cli=\u003cVERSION_STRING\u003e containerd.io docker-compose-plugin 6. 测试是否安装成功 sudo docker run hello-world 如下，则成功 Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:10d7d58d5ebd2a652f4d93fdd86da8f265f5318c6a73cc5b6a9798ff6d2b2e67 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ 7. 卸载 sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:1:1","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"常用docker命令 docker ps 查看当前运行中的容器 docker images 查看镜像列表 docker rm container-id 删除指定 id 的容器 docker stop/start container-id 停止/启动指定 id 的容器 docker rmi image-id 删除指定 id 的镜像 docker volume ls 查看 volume 列表 docker network ls 查看网络列表 ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:1:2","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"2. 编写dockerfile制作深度学习镜像 ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:0","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"dockerfile指令 FROM #基础镜像 一切从这里开始构建 MAINTAINER #镜像是谁写的 名字+邮箱 RUN #镜像构建的时候需要运行的命令 ADD #步骤，tomcat镜像，加一个tomcat压缩包！添加内容 WORKDIR #镜像的工作目录 VOLUME #挂载的目录 EXPOSE #指定暴露端口 CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代 ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD #当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令 COPY #类似ADD，将我们的文件拷贝到镜像中 ENV #构建的时候设置环境变量 更多参考 dockerfile文档 菜鸟dockerfile文档 dockerfile构建镜像的时候是运行一行命令构建一个，意思就是每行命令运行结束后，运行之后的命令都是一个新的环境 例如 RUN cd /opt/conda 后再运行其他命令基于的目录仍是 根目录，而不是/opt/conda 如有需要，可以使用\u0026\u0026来连接多条指令 ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:1","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"多级构建 比如我们要使用cuda、anaconda等多个基础环境的时候就会用到多级构建 多级构建需要用到COPY命令来复制上级环境，用法如下 FROM image-1 as base WORKDIR /base RUN do something FROM image-2 as bulid WORKDIR /bulid COPY --from=base /base ./build/base ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:2","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"WORKDIR 工作目录，设置这个后，运行这个镜像直接进入到这个目录 在dockerfile中某一级别设置工作目录后，之后的命令都会在这个目录下进行（因为再次进入这个镜像的默认目录就是工作目录） ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:3","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"使用conda打包环境，供离线安装 1. 安装打包工具 pip install conda-pack 2. 打包conda环境 conda pack -n 虚拟环境名称 -o xxx.tar.gz 或者 conda pack -n 虚拟环境名称 --ignore-editable-packages -o xxx.tar.gz 3. 上传到需要安装的机器上，解压安装 为了方便使用conda命令激活，推荐解压到anaconda安装目录的envs目录中 在envs目录下创建环境名 mkdir env_name 解压环境 tar -xzf xxx.tar.gz -C env_name 激活使用环境 conda env list source activate env_name ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:4","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"实例：打包mmsegmentation深度学习环境 dockerfile的RUN命令默认是使用/bin/sh # 从conda开始构建 FROM continuumio/anaconda3:2020.07 # 作者 MAINTAINER xxxx # 从cuda复制基础环境 COPY --from=nvidia/cuda:11.4.0-devel-ubuntu20.04 / / # 复制代码 COPY swin_seg /swin_seg # 复制conda环境 COPY mmseg.tar.gz /opt/conda/envs/ # 解压、创建conda环境 RUN mkdir /opt/conda/envs/mmseg RUN tar -zxf /opt/conda/envs/mmseg.tar.gz -C /opt/conda/envs/mmseg # 设置全局shell环境，使用/bin/bash SHELL [\"/bin/bash\",\"-c\"] # 安装mmcv的环境 WORkDIR /swin_seg RUN source activate mmseg \u0026\u0026 pip install -r requirements.txt \u0026\u0026 pip install --no-cache-dir -e . RUN echo \"source activate mmseg\" \u003e\u003e ~/.bashrc 编译、构建镜像 docker build -t swin_seg:v1 . 导出镜像 格式：docker save imagesID(或者image_id) \u003e /存放位置/打包文件名.tar 参考 docker save imagesID \u003e /xxx.tar 导入 格式：docker load \u003c 打包文件名.tar docker load \u003c xx.tar ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:5","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["docker","开发工具"],"content":"运行深度学习镜像 使用显卡，需要安装NVIDIA Container Toolkit 安装参考NVIDIA Container Toolkit安装指南 运行容器需要注意两个参数 docker run -idt --shm-size 4096m --gpus all --name swin_seg xx:xx # 参数一 --shm-size # 设置容器的共享内存大小，这里设置的4g # 参数二 --gpus all # 开启gpu 详细文档 ","date":"2022-06-08","objectID":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:6","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["中间件"],"content":"kafka的入门使用 ","date":"2022-06-06","objectID":"/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:0:0","tags":["kafka","消息队列"],"title":"kafka的入门使用","uri":"/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":["中间件"],"content":"kafka入门 启动zookeeper bin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties 启动kafka bin\\windows\\kafka-server-start.bat config\\server.properties 创建主题 kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test ","date":"2022-06-06","objectID":"/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:1:0","tags":["kafka","消息队列"],"title":"kafka的入门使用","uri":"/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":["中间件"],"content":"springboot整合kafka 引入依赖，spring-kafka \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.kafka\u003c/groupId\u003e \u003cartifactId\u003espring-kafka\u003c/artifactId\u003e \u003c/dependency\u003e 配置kafka，配置server、consumer spring: kafka: bootstrap-servers: localhost:9092 consumer: group-id: test-consumer-group enable-auto-commit: true auto-commit-interval: 3000 访问kafka 生产者使用 kafkaTemplate.send(topic,content);发送消息 消费者使用@KafkaListener(topics = {“test”})注解监听某些主题，消息封装成ConsumerRecord类型handleMessage(ConsumerRecord consumerRecord) @SpringBootTest(classes = NowcoderCommunityApplication.class) public class KafkaTest { @Autowired private KafkaProducer kafkaProducer; @Test public void testKafka(){ kafkaProducer.sendMessage(\"test\",\"这是第一条kafkaProducer\"); kafkaProducer.sendMessage(\"test\",\"hah\"); kafkaProducer.sendMessage(\"test\",\"你好\"); try { Thread.sleep(1000*5); } catch (InterruptedException e) { e.printStackTrace(); } } } //生产者 @Component class KafkaProducer{ @Autowired private KafkaTemplate kafkaTemplate; public void sendMessage(String topic,String content){ kafkaTemplate.send(topic,content); } } //消费者 @Component class KafkaConsumer{ @Autowired private KafkaTemplate kafkaTemplate; //监听某些主题 @KafkaListener(topics = {\"test\"}) public void handleMessage(ConsumerRecord consumerRecord){ System.out.println(consumerRecord.value()); } } ","date":"2022-06-06","objectID":"/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:2:0","tags":["kafka","消息队列"],"title":"kafka的入门使用","uri":"/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":["中间件"],"content":"Redis ","date":"2022-06-05","objectID":"/redis%E5%9F%BA%E7%A1%80/:0:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["中间件"],"content":"安装 ","date":"2022-06-05","objectID":"/redis%E5%9F%BA%E7%A1%80/:1:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["随想"],"content":"明里的hugo博客 博客基于hugo 使用的是loveI主题 使用hugo构建静态文件时默认是生成在public目录下 可以在config中设置publishDir = \"xxx\" 来指定目录 ","date":"2022-06-01","objectID":"/about/:1:0","tags":["关于"],"title":"About","uri":"/about/"},{"categories":["java基础"],"content":"3.23 单元测试、反射、注解、工厂模式、装饰模式 单元测试 单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。 Junit单元测试框架 JUnit是使用Java语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnit编写单元测试 此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试，JUnit目前最新版本是5。 JUnit优点 JUnit可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。 Junit可以生成全部方法的测试报告。 单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。 单元测试快速入门 将JUnit的jar包导入到项目中 编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法。 在测试方法上使用 @Test 注解：标注该方法是一个测试方法 在测试方法中完成被测试方法的预期正确性测试。 Assert.assertEquals(); 选中测试方法，选择“JUnit运行” ，如果测试良好则是绿色；如果测试失败，则是红色 Junit常用注解(Junit 4.xxxx版本) @Test : 测试方法。 @Before : 用来修饰 实例方法，该方法会在每一个测试方法执行之前执行一次。 junit5为@BeforeEach @After : 用来修饰 实例方法，该方法会在每一个测试方法执行之后执行一次。 junit5为@AftereEach @BeforeClass : 用来 静态修饰方法，该方法会在所有测试方法之前只执行一次。 junit5为@BeforeAll @AfterClass : 用来 静态修饰方法，该方法会在所有测试方法之后只执行一次。 junit5为@AfterAll 开始执行的方法:初始化资源 执行完之后的方法:释放资源 反射 获取class对象 //1. Class.forName() Class c = Class.forName(\"com.day7.People\"); System.out.println(c); //2. 类名.class Class c1= Studnet.class; System.out.println(c1); //3. getClass() Studnet s=new Studnet(); Class c2=s.getClass(); System.out.println(c2); 注解 注解概述、作用 Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制 Java 语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。 注解的作用是什么呢 对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。 例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。 自定义注解 — 格式 public @interface 注解名称 { public 属性类型 属性名() default 默认值 ; } 特殊属性 value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写!! 但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。 元注解：就是注解 注解的注解 元注解有两个： @Target: 约束自定义注解只能在哪些地方使用 @Retention：申明注解的生命周期 解析注解的技巧 注解在哪个成分上，我们就先拿哪个成分对象。 比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解 比如注解作用在类上，则要该类的Class对象，再来拿上面的注解 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解 工厂模式 什么是工厂模式 之前我们创建类对象时, 都是使用new 对象的形式创建,在很多业务场景下也提供了不直接new的方式 。 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一， 这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。 工厂设计模式的作用： 工厂的方法可以封装对象的创建细节，比如：为该对象进行加工和数据注入。 可以实现类与类之间的解耦操作（核心思想）。 装饰模式 ​ ","date":"2022-03-19","objectID":"/javase/:1:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.18 多线程 多线程 多线程是指从软硬件上实现多条执行流程的技术。 多线程的创建 方式一：继承Thread类 Thread类,Java是通过java.lang.Thread 类来代表线程的。 多线程的实现方案一：继承Thread类 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法 创建MyThread类的对象 调用线程对象的start()方法启动线程（启动后还是执行run方法的） 优点：编码简单 缺点：线程类已经继承Thread，无法继承其他类，不利于扩展 问答 为什么不直接调用了run方法，而是调用start启动线程。 直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。 只有调用start方法才是启动一个新的线程执行。 把主线程任务放在子线程之前了。 这样主线程一直是先跑完的，相当于是一个单线程的效果了 方式二：实现Runnable接口 多线程的实现方案二：实现Runnable接口 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法 创建MyRunnable任务对象 把MyRunnable任务对象交给Thread处理。 调用线程对象的start()方法启动线程 优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。 缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的。 实现Runnable接口(匿名内部类形式) 可以创建Runnable的匿名内部类对象。 交给Thread处理。 调用线程对象的start()启动线程。 前两种方式的问题 方式三：JDK 5.0新增：利用Callable、FutureTask接口实现 得到任务对象 定义类实现Callable接口，重写call方法，封装要做的事情。 用FutureTask把Callable对象封装成线程任务对象 把线程任务对象交给Thread处理 调用Thread的start方法启动线程，执行任务 线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。 三种方式比较 线程安全 什么是线程安全 多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题 线程安全问题出现的原因？ 存在多线程并发 同时访问共享资源 存在修改共享资源 线程同步 让多个线程实现先后依次访问共享资源，这样就解决了安全问题 线程同步的核心思想 加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。 方式一：同步代码块 作用：把出现线程安全问题的核心代码给上锁。 原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。 操作共享资源的代码(核心代码) } ``` 锁对象要求, 理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可。 方式二：同步方法 作用：把出现线程安全问题的核心方法给上锁。 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。 格式 修饰符 synchronized 返回值类型 方法名称(形参列表) { 操作共享资源的代码 } 同步方法底层原理 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。 如果方法是实例方法：同步方法默认用this作为的锁对象。但是代码要高度面向对象 如果方法是静态方法：同步方法默认用类名.class作为的锁对象。 同步代码块锁的范围更小，同步方法锁的范围更大。 方式三：Lock锁 为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。 Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。 Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。 public ReentrantLock(),获得Lock锁的实现类对象 Lock的API,lock()获得锁，unlock()释放锁 线程通信 所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信。 通过共享一个数据的方式实现。 根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。 线程通信实际应用场景 生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据 要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。 线程通信的前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。 Object类的等待和唤醒方法： 线程池[重点] 线程池就是一个可以复用线程的技术。如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。 JDK 5.0起提供了代表线程池的接口：ExecutorService 如何得到线程池对象 方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象 线程池常见面试题 临时线程什么时候创建啊？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。 什么时候会开始拒绝任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。 线程池如何处理Callable任务，并得到任务执行完后返回的结果。 使用ExecutorService的方法： Future submit(Callable command) 方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象（不推荐） public static ExecutorService newFixedThreadPool​(int nThreads) 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 定时器 定时器是一种控制任务延时调用，或者周期调用的技术。 作用：闹钟、定时邮件发送。 定时器的实现方式 方式一：Timer 方式二： ScheduledExecutorService ","date":"2022-03-19","objectID":"/javase/:2:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.18 缓冲流、序列化、Properties、commons-io 缓冲流 缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流 作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能 建议使用字节缓冲输入流、字节缓冲输出流，结合字节数组的方式，目前来看是性能最优的组合 对象序列化 作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化 使用到的流是对象字节输出流：ObjectOutputStream 对象必须实现序列化接口Serializable 对象反序列化 使用到的流是对象字节输入流：ObjectInputStream 作用：以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。 打印流 打印流一般是指：PrintStream，PrintWriter两个类。 打印功能2者是一样的使用方式 PrintStream继承自字节输出流OutputStream，支持写字节 PrintWrite继承自字符输出流Writer，支持写字符 两者在打印功能上都是使用方便，性能高效（核心优势） Properties Properties属性集对象 其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。 Properties核心作用： Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。 属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value，后续做系统配置信息的。 properties的API commons-io commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。 commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils, IOUtils FileUtils主要有如下方法: String readFileToString(File file, String encoding), 读取文件中的数据, 返回字符串 void copyFile(File srcFile, File destFile), 复制文件。 void copyDirectoryToDirectory(File srcDir, File destDir), 复制文件夹。 ","date":"2022-03-19","objectID":"/javase/:3:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.17 不可变集合、Stream、异常体系、日志框架、File、IO流 不可变集合 集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错 为什么要创建不可变集合？ 如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践 或者当集合对象被不可信的库调用时，不可变形式是安全的。 List、Set、Map接口中，都存在of方法可以创建不可变集合，jdk9开始才有 Stream流 暂无、跳过 异常体系 运行时异常 直接继承自RuntimeException或者其子类，编译阶段不会报错，运行时可能出现的错误。 运行时异常示例 数组索引越界异常: ArrayIndexOutOfBoundsException 空指针异常 : NullPointerException，直接输出没有问题，但是调用空指针的变量的功能就会报错。 数学操作异常：ArithmeticException 类型转换异常：ClassCastException 数字转换异常： NumberFormatException 运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，自己的水平有问题！ 编译时异常 不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过 编译时异常的处理形式有三种： 出现异常直接抛出去给调用者，调用者也继续抛出去。 throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。 这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。 抛出异常格式： 方法 throws 异常1 ，异常2 ，异常3 ..{ } //代表可以抛出一切异常 方法 throws Exception{ } 出现异常自己捕获处理，不麻烦别人。 try…catch… 监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。 这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。 格式 try{ // 监视可能出现异常的代码！ }catch(异常类型1 变量){ // 处理异常 }catch(异常类型2 变量){ // 处理异常 } 建议格式： try{ // 可能出现异常的代码！ }catch (Exception e){ e.printStackTrace(); // 直接打印异常栈信息 } //Exception可以捕获处理一切异常类型！ throws/throw 关键字： 如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。 public class className { public void deposit(double amount) throws RemoteException { // Method implementation throw new RemoteException(); } //Remainder of class definition } finally关键字 finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }finally{ // 程序代码 } 前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。 方法直接将异通过throws抛出去给调用者 调用者收到异常后直接捕获处理。 异常处理的总结 在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理 实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的 自定义异常类 Java无法为这个世界上全部的问题提供异常类。如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。 可以使用异常的机制管理业务问题，如提醒程序员注意。同时一旦出现bug，可以用异常的形式清晰的指出出错的地方。 自定义异常的分类 自定义编译时异常 定义一个异常类继承Exception. 重写构造器。 在出现异常的地方用throw new 自定义对象抛出， 作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！ 自定义运行时异常 定义一个异常类继承RuntimeException. 重写构造器。 在出现异常的地方用throw new 自定义对象抛出! 作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！ //自定义异常 public class myException extends Exception{ public myException() { System.out.println(\"自定义异常\"); } } //抛出异常 public class Demo { public void test() throws myException { System.out.println(\"开始抛出异常\"); throw new myException(); } } //捕获异常 Demo d=new Demo(); try { d.test(); } catch (myException e) { e.printStackTrace(); } System.out.println(\"异常抛出\"); 日志框架 日志技术具备的优势 可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。 可以随时以开关的形式控制是否记录日志，无需修改源代码。 log4j很流行，但是logback更好，是他的升级版 Logback 介绍 Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好 Logback是基于slf4j的日志规范实现的框架。 Logback主要分为三个技术模块： logback-core： logback-core 模块为其他两个模块奠定了基础，必须有。 logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API。 logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能 Logback快速入门 日志级别 File类使用 File类创建对象 public File​(String pathname),根据文件路径创建文件对象 public File​(String parent, String child),从父路径名字符串和子路径名字符串创建文件对象 public File​(File parent, String child),根据父路径对应文件对象和子路径名字符串创建文件对象 File对象可以定位文件和文件夹 File封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。 IO流 总结流的四大类: 字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流。 字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流。 字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。 字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。 字节流 资源释放 ","date":"2022-03-19","objectID":"/javase/:4:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.16 Map集合 Map集合 Map集合概述和使用 Map集合是一种双列集合，每个元素包含两个数据。 Map集合的每个元素的格式：key=value(键值对元素)。 Map集合也被称为“键值对集合”。 Map集合的完整格式：{key1=value1 , key2=value2 , key3=value3 , …} Map集合体系 Map集合体系特点 Map集合的特点都是由键决定的。 Map集合的键是无序,不重复的，无索引的，值不做要求（可以重复）。 Map集合后面重复的键对应的值会覆盖前面重复键的值。 Map集合的键值对都可以为null。 Map集合实现类特点 HashMap:元素按照键是无序，不重复，无索引，值不做要求。（与Map体系一致） LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求。 TreeMap：元素按照键是排序，不重复，无索引的，值不做要求。 Map集合的遍历方式有：3种。 方式一：键找值的方式遍历：先获取Map集合全部的键，再根据遍历键找值。 方式二：键值对的方式遍历，把“键值对“看成一个整体，难度较大。 方式三：JDK 1.8开始之后的新技术：Lambda表达式。 得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。 System.out.println(k +\"-----\u003e\" + v); }); HashMap HashMap跟HashSet底层原理是一模一样的，都是哈希表结构，只是HashMap的每个元素包含两个值而已 实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。 map = new HashMap\u003c\u003e(); } LinkedHashMap 原理：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。 TreeMap 可排序：按照键数据的大小默认升序（有小到大）排序。只能对键排序。 注意：TreeMap集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序 TreeMap跟TreeSet一样底层原理是一样的。 ","date":"2022-03-19","objectID":"/javase/:5:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.15 数据结构、List系列集合、泛型、Set系列集合 数据结构 栈：后进先出，先进后出 队列：先进先出，后进后出 数组：数组是一种查询快，增删慢的模型 查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同。（元素在内存中是连续存储的） 删除效率低：要将原始数据删除，同时后面每个数据前移。 添加效率极低：添加位置后的每个数据后移，再添加元素 链表： 链表中的元素是在内存中不连续存储的，每个元素节点包含数据值和下一个元素的地址 链表查询慢。无论查询哪个数据都要从头开始找 链表增删相对快 二叉树 只能有一个根节点，每个节点最多支持2个直接子节点 节点的度： 节点拥有的子树的个数，二叉树的度不大于2 叶子节点 度为0的节点，也称之为终端结点 高度：叶子结点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高。 层：根节点在第一层，以此类推 兄弟节点 ：拥有共同父节点的节点互称为兄弟节点 平衡二叉树：平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能 红黑树 List系列集合 特点： ArrayList、LinekdList ：有序，可重复，有索引。 有序：存储和取出的元素顺序一致 有索引：可以通过索引操作元素 可重复：存储的元素可以重复 List的实现类的底层原理 ArrayList底层是基于数组实现的，根据查询元素快，增删相对慢。 LinkedList底层基于双链表实现的，查询元素慢，增删首尾元素是非常快的。 List集合的遍历方式有几种: 迭代器(推荐，更安全) 、增强for循环、Lambda表达式、for循环（因为List集合存在索引） LinkedList的特点：底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。 //linkedlist可以完成队列、栈结构，因为它是双链表结构 //栈 LinkedList\u003cString\u003e stack=new LinkedList\u003c\u003e(); //入栈 // stack.addFirst(\"1\"); // stack.addFirst(\"2\"); // stack.addFirst(\"3\"); stack.push(\"1\"); //push就是addFirst System.out.println(stack); //[3, 2, 1] //出栈 // System.out.println(stack.removeFirst()); //3 // System.out.println(stack.removeFirst()); //2 // System.out.println(stack.removeFirst()); //1 System.out.println(stack.pop()); //pop就是removeFirst() //队列 LinkedList\u003cString\u003e queue=new LinkedList\u003c\u003e(); //入队 queue.addLast(\"A\"); queue.addLast(\"B\"); queue.addLast(\"C\"); System.out.println(queue); //[A, B, C] //出队 System.out.println(queue.removeFirst()); System.out.println(queue.removeFirst()); System.out.println(queue.removeFirst()); 集合的并发修改异常问题 Iterator迭代器中的remove的方法需要在next()方法调用后才能调用，且只能使用一次 泛型 泛型概述 泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查 泛型类的原理：把出现泛型变量的地方全部替换成传输的真实数据类型 泛型的格式：\u003c数据类型\u003e; 注意：泛型只能支持引用数据类型 泛型类的格式：修饰符 class 类名\u003c泛型变量\u003e{ } 泛型方法的格式：修饰符 \u003c泛型变量\u003e 方法返回值 方法名称(形参列表){} 泛型接口的格式：修饰符 interface 接口名称\u003c泛型变量\u003e{} 集合体系的全部接口和实现类都是支持泛型的使用的 泛型的好处 统一数据类型 把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来 通配符:? ? 可以在“使用泛型”的时候代表一切类型。 E T K V 是在定义泛型的时候使用的 泛型的上下限： ? extends Car: ?必须是Car或者其子类 泛型上限 ? super Car ： ?必须是Car或者其父类 泛型下限 Set系列集合 Set系列集合特点 无序：存取顺序不一致 不重复：可以去除重复 无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素 Set集合实现类特点 HashSet : 无序、不重复、无索引 LinkedHashSet：有序、不重复、无索引 TreeSet：排序、不重复、无索引 HashSet底层原理 HashSet集合底层采取哈希表存储的数据,哈希表是一种对于增删改查数据性能都较好的结构。 哈希表的组成 JDK8之前的，底层使用数组+链表组成 JDK8开始后，底层采用数组+链表+红黑树组成。 jdk8的hashset原理 哈希表（数组、链表、红黑树的结合体） 当挂在元素下面的数据过多时，查询性能降低，从JDK8开始后，当链表长度超过8的时候，自动转换为红黑树 HashSet去重复原理解析 LinkedHashSet 有序、不重复、无索引。 这里的有序指的是保证存储和取出的元素顺序一致 原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。 TreeSet 不重复、无索引、可排序 可排序：按照元素的大小默认升序（有小到大）排序。 TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。 注意：TreeSet集合是一定要排序的，可以将元素按照指定的规则进行排序。 想要使用TreeSet存储自定义类型，需要制定排序规则 自定义排序规则,TreeSet集合存储对象的的时候有2种方式可以设计自定义比较规则 让自定义的类（如学生类）实现Comparable接口重写里面的compareTo方法来定制比较规则。 TreeSet集合有参数构造器，可以设置Comparator接口对应的比较器对象，来定制比较规则。 public TreeSet(Comparator\u003c? super E\u003e comparator) { this(new TreeMap\u003c\u003e(comparator)); } 可变参数 可变参数用在形参中可以接收多个数据。可变参数的格式：数据类型…参数名称 传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组 可变参数在方法内部本质上就是一个数组 可变参数的注意事项 一个形参列表中可变参数只能有一个 可变参数必须放在形参列表的最后面 Collections集合工具类 java.utils.Collections:是集合工具类 作用：Collections并不属于集合，是用来操作集合的工具类。 ","date":"2022-03-19","objectID":"/javase/:6:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.14 Arrays、二分查找、lambda表达式 Arrays 二分查找 /** * 二分查找法 */ public class BinarySearch { // 二分查找法,在有序数组arr中,查找target // 如果找到target,返回相应的索引index // 如果没有找到target,返回-1 public static int find(Comparable[] arr, Comparable target) { // 在arr[l...r]之中查找target int l = 0, r = arr.length-1; while( l \u003c= r ){ //int mid = (l + r)/2; // 防止极端情况下的整形溢出，使用下面的逻辑求出mid int mid = l + (r-l)/2; if( arr[mid].compareTo(target) == 0 ) return mid; if( arr[mid].compareTo(target) \u003e 0 ) r = mid - 1; else l = mid + 1; } return -1; } } Lambda表达式 附录 集合 ArrayList\u003cString \u003e arrayList=new ArrayList\u003c\u003e(); arrayList.add(\"google\"); arrayList.add(\"baidu\"); arrayList.add(\"tencent\"); arrayList.add(\"bytedance\"); arrayList.add(\"jd\"); //forEach arrayList.forEach(new Consumer\u003cString\u003e() { @Override public void accept(String s) { System.out.println(s); } }); ","date":"2022-03-19","objectID":"/javase/:7:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.13 内部类 静态内部类中可以直接访问外部类的静态成员 匿名内部类 常用API Object类 Objects类，jdk1.7后才有 在比较前会做一个是否为null的判断，避免空指针异常，更加安全 StringBuilder 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 Math System BigDecimal System.out.println(0.09+0.01); double a=0.09,b=0.01; System.out.println(a+b); BigDecimal ba=BigDecimal.valueOf(a); BigDecimal bb=BigDecimal.valueOf(b); System.out.println(ba.add(bb)); //输出 0.09999999999999999 0.09999999999999999 0.10 注意：BigDecimal是一定要做精度运算的 BigDecimal a = BigDecimal.valueOf(10.0); BigDecimal b = BigDecimal.valueOf(3.0); //BigDecimal c=a.divide(b); //报错，因为10/3是无限循环，得不到精确值 BigDecimal c = a.divide(b, 2, RoundingMode.HALF_UP); //四舍五入，精确2位 System.out.println(c); 日期格式化和解析 包装类 正则表达式 ","date":"2022-03-19","objectID":"/javase/:8:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.11 多态 多态 ","date":"2022-03-19","objectID":"/javase/:9:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.10 final关键字、常量、枚举、抽象类和抽象方法、接口 包：package,相同包下的口语直接访问，否则需要import导入，加入一个类中需要用到不同类，这两个类名又是一样的，那么默认只能导入一个类，另一个需要通过带包名访问 final关键字 常量 枚举 抽象类和抽象方法 抽象类是用来被继承的，抽象方法是交给子类重写实现的 一个类如果继承了抽象类，那么这个类必须重写抽象类的全部抽象方法，除非这个类也定义为抽象类 面试题 接口 JDK8接口新增方法 JDK9接口新增方法 注意事项 接口不能创建对象 一个类实现多个接口，多个接口中有同样的静态方法不冲突，因为接口的静态方法只能通过接口名来调用，子类无法调用 一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的 public class Test { public static void main(String[] args) { ErHa er = new ErHa(); er.eat(); } } interface Animal { default void eat() { System.out.println(\"接口eat\"); } } class Dog { public void eat() { System.out.println(\"class eat\"); } } class ErHa extends Dog implements Animal { } 一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，整个类重写该方法即可 一个接口继承多个接口是可以的，如果多个接口存在规范冲突则不能多继承。 ","date":"2022-03-19","objectID":"/javase/:10:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.9 static关键字使用、代码块、单例模式、继承 java进阶 static关键字使用 静态成员变量，有static修饰,属于类，只在类第一次加载时创建，可以被共享访问，通过类名.变量名 或者对象名.变量名 静态成员方法，有static修饰，归属类，用类名访问 static 访问注意事项： 静态方法只能访问静态的成员，不可以直接访问实列成员 实例方法可以访问静态的成员，也可以访问实列成员 静态方法中是不可以出现this关键字的 工具类不用创建对象，都是静态成员方法，可以写一个private的构造函数 代码块 public class StaticCode { /** * 静态代码块，static修饰,与类一起加载，自动触发执行 * 作用：可以用于初始化静态资源 */ public static int num; static { System.out.println(\"这是静态代码块\"); num = 0; } public static void main(String[] args) { } } 单例模式 可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象 例如任务管理器对象哦我们只需要一个就可以解决问题了，这样口语节省内存空间 实现方式很多： 饿汉单例：在用类获取对象的时候，对象以及提前为你创建好了 public class SingleInstance { //饿汉单例设计模式 /** * 饿汉单例设计模式：在用类获取对象的时候，对象以及提前为你创建好了 * 2.这个对象只能是一个，所以定义为静态成员变量！ */ public static SingleInstance instance=new SingleInstance(); /** * 1.必须把构造器私有化 */ private SingleInstance(){ } } 懒汉单例：真正需要该对象的是，才去创建一个对象（延迟加载对象） public class LanSingleInstance { //设置成私有的，防止通过类名直接取null的对象 private static LanSingleInstance instance; //null //提供静态成员方法返回对象 public static LanSingleInstance getInstance() { //只需第一次创建 if (instance == null) { instance = new LanSingleInstance(); } return instance; } //构造函数私有 private LanSingleInstance() { } } 继承 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 class 父类 { } class 子类 extends 父类 { } 重写 构造器：子类构造器一定要调用父类构造器，无论是有参还是无参构造器，一定要调用 super(),this()构造器必须在构造器的第一行 ","date":"2022-03-19","objectID":"/javase/:11:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.8 String、ArrayList集合 String类 java.lang.String ,对象不可更改类型，创建的对象不可更改，String变量每次的修改其实都是产生并指向了新的字符串对象，原来的字符串对象都市没有改变的，所以称不可变字符串 //创建字符串， //方式一 String str1 = \"方式一 this is a string\"; System.out.println(str1); //方式二 //1.public String() :创建一个空白字符串，不含任何内容，几乎不用 String str2=new String(); System.out.println(str2); //2.public string(string) 根据传入的字符串内容来创建字符串对象，几乎不用 String str3=new String(\"i am chinese\"); System.out.println(str3); //3.public string (char [] c) : 根据字符数组的内容来创建字符串对象 char c[]={'a','b','v','i','中','国'}; String str4=new String(c); System.out.println(str4); //4. public string(byte []):根据字节数组的内容来创建字符串对象 byte [] b={97,98,99,100,101,102,103}; String str5=new String(b); System.out.println(str5); 面试题 Q 有什么区别 A 以\"“方式给出的字符串对象，在字符串常量池中存储 ，而且相同内容只会在其中存储一份 通过构造器的new对象，每new一次都会产生一个新的对象，放在堆内存中 Q //这行代码创建了两个对象，new一个，常量\"abc\"一个 String s2 = new String(\"abc\"); //这行代码创建了0个对象 String s1 = \"abc\"; //地址不同，false System.out.println(s1 == s2); String str1=\"abc\"; string str2=\"ab\"; String str3=s2+\"c\"; //只要没明确写出是字符串，都会new新对象放在堆内存中 ArrayList集合 //泛型 //jdk17开始，泛型后面的类型声明可以不写 ArrayList\u003cString\u003e list=new ArrayList\u003c\u003e(); ArrayList\u003cString\u003e list=new ArrayList\u003cString \u003e(); list.add(\"java\"); list.add(\"c\"); list.add(\"c++\"); list.add(\"python\"); list.add(\"js\"); list.add(\"html\"); //1.public E get(int index)：获取某个位置出的元素值 System.out.println(list.get(0)); //2.public int size() 获取集合的大小 System.out.println(list.size()); //3.集合遍历 for (String s : list) { System.out.println(s); } //4.public E remove(int index) :删除某个索引，并返回被删除的元素值 String str2=list.remove(0); System.out.println(str2); System.out.println(list); list.remove(\"java\"); // remove(object o )只会删除第一次出现的元素，后面出现的不会删除 //5. public E set(int index,E element): 修改某个索引位置的元素值 list.set(0,\"c++\"); System.out.println(list); ","date":"2022-03-19","objectID":"/javase/:12:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.7 摸鱼 ","date":"2022-03-19","objectID":"/javase/:13:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.6 摸鱼 ","date":"2022-03-19","objectID":"/javase/:14:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.5 方法重载、面向对象 方法 修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值; } 递归求1-n的和 //求1-n的值 public static int nSum(int n){ if(n!=0){ return n+nSum(n-1); }else { return n; } } java中的参数传递机制： 基本类型的参数传递，是值传递，传的是数据值，并不是传地址 引用类型的参数传递，传的是地址 方法重载：同一个类中，出现多个方法名称相同，但是形参列表不同，那么这些方法就是重载方法 形参列表不同是指，形参个数、类型、顺序不同 return可以单独使用，立即跳出，结束当前方法 面向对象 三大特征：封装、继承、多态 构造器 无参数构造器（默认存在的），写不写都有，一旦定义了有参构造器，那么无参构造器就没有了，还想用无参构造器就必须自己写一个 有参数构造器 this关键字 可以出现再构造器和方法中、代表当前对象的地址 用于指定访问当前对象的成员变量、成员方法 ","date":"2022-03-19","objectID":"/javase/:15:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.4 三种控制结构，顺序、分支、循环 冒泡排序 三种控制结构，顺序、分支、循环 switch注意事项： 表达式类型只能是byte、short、int、char，jdk5开始支持枚举，jkd7支持String,不支持double、float，因为double、float底层计算不精确，不支持long,因为太大了 case给出得值不允许重复，且只能是字面量，不能是变量 不要忘记写break，否则会出现穿透现象 for循环 for (初始化; 循环语句; 迭代语句){ } for (int i = 0; i++ \u003c 10; System.out.println(i)){ //输出1-10 } 冒泡排序 比较轮数为 数组长度-1 每轮次数为 数组长度-i-1 int [] arr={6,5,4,3,2,1}; for (int i = 0; i \u003c arr.length-1; i++) { for (int j = 0; j \u003c arr.length-i-1 ; j++) { if(arr[j]\u003earr[j+1]){ int temp=arr[j+1]; arr[j+1]=arr[j]; arr[j]=temp; } System.out.println(\"第\"+i+\"轮\"+Arrays.toString(arr)); } } System.out.println(\"排序完成：\"+Arrays.toString(arr)); ","date":"2022-03-19","objectID":"/javase/:16:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.3 基本数据类型：四大类8种、自动类型转换 JAVA中的数据类型，引用数据类型（除基本数据类型外都是,例如String）和基本数据类型 基本数据类型：四大类8种 整数 byte 1字节 short 2字节 int 4字节 long 8字节 long l=1234165464L 不加L默认是int 浮点数 float 4字节 float score=98.5F 不加F默认是double double 8字节 字符 char 2字节 布尔 boolean1字节 自动类型转换 类型范围小的变量，考研直接赋值给类型范围大的变量 byte a=12; 原理: a 00001100 （8位） int b=a; b 00000000 00000000 00000000 00001100 (32位) System.out.println(b); // b=12 byte short char 是直接转换成int类型参与运算的 类型转换面试题，byte i=10; byte j=120; byte k=i+j;(不行，byte在运算中当做int,所有k要声明为int) 因为byte太小，运算容易越界，所有干脆直接当作int运算 *\u0026\u0026 短路与，左边为false，右边不执行 *|| 短路或，左边为true,右边不执行 *三元运行符 条件？a:b int max=a\u003eb ？ a:b 三元运算符嵌套，int max = i\u003ej? (i\u003ek? i: k) : (j\u003ek? j: K) ","date":"2022-03-19","objectID":"/javase/:17:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["java基础"],"content":"3.2 git入门 学习了git使用，搭建了docsify个人博客，主要用于记录学习过程，Java笔记 其中git使用常用命令为： git init 初始化仓库 git add xxx.xx 添加文件 git add -A 添加所有修改的文件 git commit -m \"xxxx\" git reset --hard HEAD^ 返回上一版本，HEAD时当前版本 git branch xxx 创建分支 git cheackout xx 切换分支 git merge xx 合并分支 git push origin xx 更新到github git status 查看当前状态 .... 附上参考资料，不会再查 ","date":"2022-03-19","objectID":"/javase/:18:0","tags":["javase"],"title":"javaSE","uri":"/javase/"},{"categories":["git","开发工具"],"content":"1. git入门 学习了git使用，搭建了docsify个人博客，主要用于记录学习过程，Java笔记 其中git使用常用命令为： git init 初始化仓库 git add xxx.xx 添加文件 git add -A 添加所有修改的文件 git commit -m \"xxxx\" git reset --hard HEAD^ 返回上一版本，HEAD时当前版本 git branch xxx 创建分支 git checkout xx 切换分支 git merge xx 合并分支 git push origin xx 更新到github git status 查看当前状态 .... 附上参考资料，不会再查 ","date":"2022-03-09","objectID":"/git%E5%85%A5%E9%97%A8/:1:0","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"}]